<<<<<<< HEAD
import { PeerData, RoomData } from "../../ServerTypes";
import type { types as MediasoupTypes } from "mediasoup";
import autoBind from "auto-bind";
class ServerStateActions {
  /** Maps user ID to a user room record (map of room IDs and peer data) */
  usersMap: Record<string, Record<string, PeerData>> = {};
  roomsMap: Record<string, RoomData> = {};
  transportsMap: Record<string, MediasoupTypes.WebRtcTransport> = {};
  producersMap: Record<string, MediasoupTypes.Producer> = {};
  consumersMap: Record<string, MediasoupTypes.Consumer> = {};
  constructor() {
    this.usersMap = {};
    this.roomsMap = {};
    this.transportsMap = {};
    this.producersMap = {};
    this.consumersMap = {};
=======
import { FullRoomInfo, PeerKeyData } from "../../ServerTypes";
import type { types as MediasoupTypes } from "mediasoup";
import autoBind from "auto-bind";
import redis from "../../lib/redis";
import {
  consumerRepository,
  peerRepository,
  producerRepository,
  roomRepository,
  routerRepository,
  transportRepository,
} from "./repositories";
import { Entity, EntityId } from "redis-om";
import { publishCheckRequest } from "./cleanup/producer";
import logs from "../../lib/logger";
class ServerStateActions {
  userPeerKeys: Record<string, PeerKeyData> = {};
  routers: Record<string, MediasoupTypes.Router> = {};
  transports: Record<string, MediasoupTypes.WebRtcTransport> = {};
  producers: Record<string, MediasoupTypes.Producer> = {};
  consumers: Record<string, MediasoupTypes.Consumer> = {};

  constructor() {
    logs.debug("CONSTRUCTING SERVER STATE --->");
    this.userPeerKeys = {};
    this.routers = {};
    this.transports = {};
    this.producers = {};
    this.consumers = {};
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
    autoBind(this);
  }

  /**
<<<<<<< HEAD
   * Check if room exists
   * @param roomId The room ID
   * @returns If the room exists
   */
  existsRoom(roomId: string) {
    return !!this.roomsMap[roomId];
=======
   * Get info on a room
   * @param roomId The room ID of the room
   * @returns the room information
   * TODO: consider speeding up.
   */
  async getRoom(roomId: string): Promise<FullRoomInfo | null> {
    const room = await roomRepository.fetch(roomId);

    if (!room.routerId || !this.routers[room.routerId]) {
      logs.warn("Room not found - getRoom! %s %s", roomId, room.routerId);
      return null;
    }
    const peerKeys = await redis.sMembers(`memberPeerKeys:room:${roomId}`);
    const router = this.routers[room.routerId];
    return { ...room, id: roomId, peerKeys, router };
  }

  /**
   * Gets room size
   * @param roomId The room ID of the room
   * @returns The number of people in this room
   */
  async getRoomSize(roomId: string) {
    return await redis.sCard(`memberPeerKeys:room:${roomId}`);
  }

  /**
   * Gets room peers
   * @param roomId The room ID
   * @returns The list of room peers
   * TODO: consider speeding up?
   */
  async getProducingRoomPeers(roomId: string) {
    const peerKeys = await redis.sMembers(`memberPeerKeys:room:${roomId}`);
    const peers = [];
    for (const peerKey of peerKeys) {
      const { userId, producerId } = await peerRepository.fetch(peerKey);
      if (producerId) {
        // NOT returning consumer since that doesn't seem necessary
        peers.push({ userId, producerId: producerId as string });
      }
    }
    return peers;
  }

  /**
   * Stores the room in server state
   * @param roomId - The ID of the room
   * @param routerId - The router for this room
   */
  async storeRoom(roomId: string, routerId: string) {
    // 1. Store room information in Redis hash.
    if (!routerId) return;
    await roomRepository.save(roomId, {
      routerId,
      sticky: false,
    });
  }

  /**
   * Stores router in cache and memory
   * @param router The router
   * @param workerId - The worker ID generated by mediasoup
   */
  async storeRouter(
    router: MediasoupTypes.Router,
    config: MediasoupTypes.RtpCodecCapability[]
  ) {
    // 1. Save router information to Redis router hash so it can be recreated if needed.
    await routerRepository.save(router.id, {
      config: JSON.stringify(config),
    });

    // 2. Save the Mediasoup router itself in local memory, since its event handlers etc can't be cached.
    this.routers[router.id] = router;
    console.log("STORED ROUTER", router.id);
  }

  /**
   * Check if room exists
   * @param roomId The room ID
   * @returns If the room exists
   * TODO: check if we need to check the cache too?
   */
  async existsRoom(roomId: string) {
    const room = await roomRepository.fetch(roomId);
    return Object.keys(room).length > 0;
  }

  /**
   * Removes a room from server state
   * @param roomId The room ID
   */
  async removeRoom(roomId: string) {
    // 1. Remove all peer key records for this room
    await redis.del(`memberPeerKeys:room:${roomId}`);

    // 2. Remove the router associated with this room.
    const { routerId } = await roomRepository.fetch(roomId);
    if (routerId) await this.removeRouter(routerId);

    // 3. Remove room from Redis room hash.
    await roomRepository.remove(roomId);
  }

  async removeRouter(routerId: string) {
    // 1. Remove router information from Redis router hash.
    await routerRepository.remove(routerId);

    // 2. Remove Mediasoup router itself from local memory.
    const { [routerId]: router, ...others } = this.routers;
    this.routers = { ...others };
    logs.info("REMOVED ROUTER FROM STATE ---> %s", routerId);
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Check if user is in room
   * @param userId The user ID of the user
   * @param roomId The room ID
   * @returns If the user is in the room
   */
<<<<<<< HEAD
  isUserInRoom(userId: string, roomId: string) {
    return (
      this.existsRoom(roomId) &&
      !!this.usersMap[userId] &&
      !!this.usersMap[userId][roomId]
    );
  }

  /**
   * Removes a room from server state
   * @param roomId The room ID
   */
  removeRoom(roomId: string) {
    const { [roomId]: _roomToRemove, ...others } = this.roomsMap;
    this.roomsMap = { ...others };
  }

  /**
   * Get info on room(s) the user is in
   * @param userId The user ID of the user
   * @returns the user's rooms
   */
  getUserPresence(userId: string) {
    return this.usersMap[userId] ?? {};
  }

  /**
   * Removes a user from server state
   * @param userId The user ID
   */
  removeUser(userId: string) {
    const { [userId]: _userToRemove, ...others } = this.usersMap;
    this.usersMap = { ...others };
  }
=======
  async isUserInRoom(userId: string, roomId: string) {
    return !!this.userPeerKeys[userId]?.[roomId];
  }

  /**
   * Get info on room(s) the user is in, and the peer keys the user has in each of those rooms.
   * @param userId The user ID of the user
   * @param fullInfo - If true, returns the full information on all rooms the user is in. By default, includes all rooms.
   * @param onlyIncludeRooms - If fullInfo is true, only include full information for rooms with these IDs.
   * @returns the user's rooms and peer keys
   */
  async getUserPresence(
    userId: string,
    fullInfo: boolean = false,
    onlyIncludeRooms: string[] = []
  ) {
    if (!fullInfo) {
      return await redis.sMembers(`peerKeys:user:${userId}`);
    }
    const fullPresenceInfo: Record<
      string,
      Record<string, string | undefined>
    > = {};

    const roomsToInclude =
      onlyIncludeRooms.length > 0
        ? onlyIncludeRooms
        : Object.keys(this.userPeerKeys[userId] ?? {});

    for (let roomId of roomsToInclude) {
      if (!this.userPeerKeys[userId]?.[roomId]) {
        console.error("Peer key for roomnot found! Cannot get user presence.");
        continue;
      }
      const peerKey = this.userPeerKeys[userId][roomId];

      fullPresenceInfo[roomId] = await this.getFullUserPresenceInfo(peerKey);
    }
    return fullPresenceInfo;
  }

  async getFullUserPresenceInfo(peerKey: string) {
    const { producerTransportId, consumerTransportId, producerId, consumerId } =
      await peerRepository.fetch(peerKey);

    return {
      peerKey,
      producerId,
      consumerId,
      producerTransportId,
      consumerTransportId,
    };
  }

>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  /**
   * Store the user in server storage
   * @param userId The user ID of the user
   * @param roomId The room ID of the room they want to join
   */
<<<<<<< HEAD
  storeUser(userId: string, roomId: string) {
    const peerData = {
      transportIds: {
        producer: null,
        consumer: null,
      },
      producerId: null,
      consumerId: null,
    };
    this.usersMap[userId] = {
      ...this.usersMap[userId],
      ...{ [roomId]: peerData },
    };
    this.roomsMap[roomId].peers[userId] = peerData;
  }

  /**
   * Removes user's peer data from server state
   * @param userId - The user ID whose peer data to delete
   * @param userPeerData - The peer data of the user (such as transport IDs, producer ID, and consumer ID)
   */
  removeUserPeerData(userId: string, userPeerData: PeerData) {
    const { transportIds, producerId, consumerId } = userPeerData;
    Object.keys(transportIds).forEach((type) => {
      const transportId = transportIds[type as "producer" | "consumer"];
      if (!!transportId) {
        this.removeTransport(transportId);
      }
    });
    if (!!producerId) {
      this.removeProducer(producerId);
    }
    if (!!consumerId) {
      this.removeConsumer(consumerId);
    }
=======
  async storeUser(userId: string, roomId: string) {
    // 1. Save peer (user-room connection) information in Redis hash.
    console.log("ABOUT TO SAVE USER", userId);
    const savedPeer: Entity = await peerRepository.save(`${userId}:${roomId}`, {
      userId,
      roomId,
      producerTransportId: "",
      consumerTransportId: "",
      producerId: "",
      consumerId: "",
    });
    // 2. Add saved peer entity's key to record of peer keys associated with this user.
    await redis.sAdd(`peerKeys:user:${userId}`, `${userId}:${roomId}`);
    // 3. Add saved peer entity's key to record of peer keys associated with the room.
    await redis.sAdd(`memberPeerKeys:room:${roomId}`, `${userId}:${roomId}`);
    // 4. Store user peer key in local memory.
    this.userPeerKeys[userId] = {
      ...this.userPeerKeys[userId],
      ...{ [roomId]: `${userId}:${roomId}` },
    };
  }

  /**
   * Removes user's peer data from server state.
   *
   * Specifically, cleans up producer, consumer, transport, and peer repositories.
   * @param peerKey: The peer's entity key
   */
  async removePeerData(peerKey: string) {
    const {
      producerTransportId,
      consumerTransportId,
      producerId,
      consumerId,
      roomId,
    } = await peerRepository.fetch(peerKey);
    logs.warn(`REMOVING  %O`, { peerKey, roomId });
    if (producerTransportId)
      await transportRepository.remove(producerTransportId);
    if (consumerTransportId)
      await transportRepository.remove(consumerTransportId);
    if (producerId) await producerRepository.remove(producerId);
    if (consumerId) await consumerRepository.remove(consumerId);
    await peerRepository.remove(peerKey);
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Removes a user from a room in server state
   * @param userId - The user ID of the user
   * @param roomId - The room ID of the room
<<<<<<< HEAD
   * @param userPeerData - The peer data of the user (such as transport IDs, producer ID, and consumer ID)
   */
  removeUserFromRoom(userId: string, roomId: string, userPeerData: PeerData) {
    const { [roomId]: roomRecord } = this.roomsMap;
    this.removeUserPeerData(userId, userPeerData);
    if (roomRecord) {
      const { [userId]: _user, ...otherPeers } = roomRecord.peers;
      if (!roomRecord.sticky) {
        if (Object.keys(otherPeers).length === 0) {
          this.removeRoom(roomId);
        }
      }
      // if there still is a room after removing empty non-sticky rooms, update peers
      if (this.roomsMap[roomId]) this.roomsMap[roomId].peers = otherPeers;
    }
    const userPresence = this.getUserPresence(userId);
    if (Object.keys(userPresence).length === 0) {
      this.removeUser(userId);
=======
   */
  async removePeer(peerKey: string) {
    const { userId, roomId } = await peerRepository.fetch(peerKey);
    // 1. Clean up all repositories storing this peer's data.
    await this.removePeerData(peerKey);

    // 2. Remove peer key from record of peer keys associated with room.
    await redis.sRem(`memberPeerKeys:room:${roomId}`, peerKey);

    // 3. Remove peer key from record of peer keys associated with user.
    await redis.sRem(`peerKeys:user:${userId}`, peerKey);

    // 4. Check if user is empty and should be auto-removed (handled separately by Redis stream).
    await publishCheckRequest(userId, "user");
    await publishCheckRequest(roomId, "room");

    const { [roomId]: room, ...others } = this.userPeerKeys[userId];
    this.userPeerKeys[userId] = { ...others };
    logs.info("userPeerKeys now %O", this.userPeerKeys);
  }

  async removePeerByUserRoomIds(userId: string, roomId: string) {
    const peerKey = this.userPeerKeys[userId]?.[roomId];
    // If this user was a peer in the given room
    if (peerKey) {
      await this.removePeer(peerKey);
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
    }
  }

  /**
<<<<<<< HEAD
   * Removes a user from all rooms in server state
   * @param userId The user ID of the user
   */
  removeUserFromAllRooms(userId: string) {
    const userRoomRecord = this.getUserPresence(userId);
    for (const [roomId, userPeerData] of Object.entries(userRoomRecord)) {
      this.removeUserFromRoom(userId, roomId, userPeerData);
    }
  }

  /**
   * Get info on a room
   * @param roomId The room ID of the room
   * @returns the room information
   */
  getRoom(roomId: string) {
    return this.roomsMap[roomId];
  }

  /**
   * Gets room size
   * @param roomId The room ID of the room
   * @returns The number of people in this room
   */
  getRoomSize(roomId: string) {
    console.log(this.roomsMap[roomId]);
    return !!this.roomsMap[roomId]?.peers
      ? Object.keys(this.roomsMap[roomId].peers).length
      : 0;
  }

  /**
   * Gets room peers
   * @param roomId The room ID
   * @returns The list of room peers
   */
  getRoomPeers(roomId: string) {
    return this.roomsMap[roomId].peers;
  }

  /**
   * Stores the room in server state
   * @param roomId - The ID of the room
   * @param router - The router for this room
   */
  storeRoom(roomId: string, router: MediasoupTypes.Router) {
    if (!!this.roomsMap[roomId]) return;
    this.roomsMap[roomId] = {
      router,
      peers: {},
      sticky: false,
    };
  }
  /**
=======
   * Removes a user from server state
   * @param userId The user ID
   */
  async removeUser(userId: string) {
    const peerKeys = await redis.sMembers(`peerKeys:user:${userId}`);
    for (let peerKey of peerKeys) {
      logs.warn(`REMOVING USER PEER FROM SERVER STATE ---> %O`, {
        peerKey,
        userId,
      });
      // 1. Remove records of peer keys in rooms this user associated with as well as the peer's more detailed record in peerRepository.
      await this.removePeer(peerKey);
    }

    // 2. Remove set of user's own peer keys.
    await redis.del(`peerKeys:user:${userId}`);

    // 3. Remove user peer key records in local memory.
    const { [userId]: _userToRemove, ...others } = this.userPeerKeys;
    this.userPeerKeys = { ...others };
  }

  /**
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
   * Stores the transport in server state
   * @param transport - The transport
   * @param userId - The user ID
   * @param roomId - The room ID
   * @param type - The type of transport ("producer" or "consumer")
   */
<<<<<<< HEAD
  storeTransport(
    transport: MediasoupTypes.WebRtcTransport,
    userId: string,
    roomId: string,
    type: "producer" | "consumer"
  ) {
    if (!!this.transportsMap[transport.id]) return;
    this.usersMap[userId][roomId] = {
      ...this.usersMap[userId][roomId],
      transportIds: {
        [type]: transport.id,
      } as Record<"producer" | "consumer", string>,
    };
    this.usersMap[userId][roomId]["transportIds"][type] = transport.id;
    this.roomsMap[roomId].peers[userId]["transportIds"][type] = transport.id;
    this.transportsMap[transport.id] = transport;
=======
  async storeTransport(
    transport: MediasoupTypes.WebRtcTransport,
    userId: string,
    roomId: string,
    type: "producer" | "consumer",
    config: MediasoupTypes.WebRtcTransportOptions
  ) {
    const peerKey = this.userPeerKeys[userId][roomId];
    await transportRepository.save(transport.id, {
      peerKey,
      roomId,
      type,
      config: JSON.stringify(config),
    });
    // Uses hSet instead of repository to update a single field instead of fetching the entire record
    const field =
      type === "producer" ? "producerTransportId" : "consumerTransportId";
    await redis.hSet(`peer:${peerKey}`, field, transport.id);
    this.transports[transport.id] = transport;
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Returns the transport from server state
   * @param transportId The transport ID
   * @returns The transport
   */
  getTransport(transportId: string) {
<<<<<<< HEAD
    return this.transportsMap[transportId];
=======
    return this.transports[transportId];
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Remove transport ID from server state
   * @param transportId The transport ID
   */
<<<<<<< HEAD
  removeTransport(transportId: string) {
    const { [transportId]: _transportToRemove, ...others } = this.transportsMap;
    this.transportsMap = { ...others };
=======
  async removeTransport(transportId: string) {
    if (!this.transports[transportId]) return;

    const { [transportId]: transportToRemove, ...others } = this.transports;

    // 1. Remove transport from Redis transport hash.
    await transportRepository.remove(transportId);

    // 2. Remove transport from local memory.
    this.transports = { ...others };
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Check if producer exists
   * @param producerId The producer ID
   * @returns If the producer exists
   */
  existsProducer(producerId: string) {
<<<<<<< HEAD
    return !!this.producersMap[producerId];
  }
  /**
   * Stores the producer in server state
   * @param producer - The producer
   * @param userId - The user ID
   * @param roomId - The room ID
   */
  storeProducer(
    producer: MediasoupTypes.Producer,
    userId: string,
    roomId: string
  ) {
    if (!!this.producersMap[producer.id]) return;
    this.usersMap[userId][roomId]["producerId"] = producer.id;
    this.roomsMap[roomId].peers[userId]["producerId"] = producer.id;
    this.producersMap[producer.id] = producer;
  }

  /**
   * Removes the producer from server state
   * @param producerId The producer ID
   * @param updateReferences Whether to update references to this producer
   * @param userId The user ID, if known
   * @param roomId The room ID, if known
   *
   */
  removeProducer(producerId: string) {
    const { [producerId]: _producerToRemove, ...others } = this.producersMap;
    this.producersMap = { ...others };
  }

  /**
   * Check if consumer exists
   * @param consumerId The consumer ID
   * @returns If the consumer exists
   */
  existsConsumer(consumerId: string) {
    return !!this.consumersMap[consumerId];
=======
    return !!this.producers[producerId];
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Returns the producer from server state
   * @param producerId The producer ID
   * @returns The producer
   */
  getProducer(producerId: string) {
<<<<<<< HEAD
    return this.producersMap[producerId];
=======
    return this.producers[producerId];
  }

  // /**
  //  * Updates the producer in server state
  //  * @param producerId Producer ID to update
  //  * @param producer the producer
  //  */
  // updateProducer(producerId: string, producer: MediasoupTypes.Producer) {
  //   if (!this.producers[producerId]) return;
  //   this.producers[producerId].producer = producer;
  // }

  /**
   * Stores the producer in server state
   * @param producer - The producer
   * @param userId - The user ID
   * @param roomId - The room ID
   * @param transportId - The transport ID
   * @param config - The configuration for the producer
   */
  async storeProducer(
    producer: MediasoupTypes.Producer,
    userId: string,
    roomId: string,
    transportId: string,
    config: Record<string, unknown>
  ) {
    await producerRepository.save(producer.id, {
      peerKey: this.userPeerKeys[userId][roomId],
      roomId,
      transportId,
      config: JSON.stringify(config),
    });
    this.producers[producer.id] = producer;
  }

  /**
   * Removes the producer from server state
   * @param producerId The producer ID
   */
  async removeProducer(producerId: string) {
    if (!this.producers[producerId]) return;
    const { [producerId]: producerToRemove, ...others } = this.producers;

    // 1. Remove producer from Redis producer hash.
    await producerRepository.remove(producerId);

    // 2. Remove producer from local memory.
    this.producers = { ...others };
  }

  /**
   * Check if consumer exists
   * @param consumerId The consumer ID
   * @returns If the consumer exists
   */
  existsConsumer(consumerId: string) {
    return !!this.consumers[consumerId];
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Stores the consumer in server state
   * @param consumer - The consumer
   * @param userId - The user ID
   * @param roomId - The room ID
<<<<<<< HEAD
   */
  storeConsumer(
    consumer: MediasoupTypes.Consumer,
    userId: string,
    roomId: string
  ) {
    if (!!this.consumersMap[consumer.id]) return;
    this.usersMap[userId][roomId]["consumerId"] = consumer.id;
    this.roomsMap[roomId].peers[userId]["consumerId"] = consumer.id;
    this.consumersMap[consumer.id] = consumer;
=======
   * @param transportId - The transport ID
   * @param config - The configuration for the consumer
   */
  async storeConsumer(
    consumer: MediasoupTypes.Consumer,
    userId: string,
    roomId: string,
    transportId: string,
    config: Record<string, unknown>
  ) {
    const savedConsumer: Entity = await consumerRepository.save(consumer.id, {
      peerKey: this.userPeerKeys[userId][roomId],
      roomId,
      transportId,
      config: JSON.stringify(config),
    });
    this.consumers[consumer.id] = consumer;
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }

  /**
   * Returns the consumer from server state
<<<<<<< HEAD
   * @param consumerId The transport ID
   * @returns The transport
   */
  getConsumer(consumerId: string) {
    return this.consumersMap[consumerId];
  }

=======
   * @param consumerId The consumer ID
   * @returns The consumer
   */
  getConsumer(consumerId: string) {
    return this.consumers[consumerId];
  }

  // /**
  //  *
  //  * @param consumerId - Consumer ID to update
  //  * @param consumer - The consumer
  //  */
  // fetch entity and save it again
  // updateConsumer(consumerId: string, consumer: MediasoupTypes.Consumer) {
  //   this.consumers[consumerId].consumer = consumer;
  // }

>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  /**
   * Removes the consumer from server state
   * @param consumerId The consumer ID
   */
<<<<<<< HEAD
  removeConsumer(consumerId: string) {
    const { [consumerId]: _consumerToRemove, ...others } = this.consumersMap;
    this.consumersMap = { ...others };
=======
  async removeConsumer(consumerId: string) {
    if (!this.consumers[consumerId]) return;
    const { [consumerId]: consumerToRemove, ...others } = this.consumers;
    // 1. Remove consumer from Redis consumer hash.
    await consumerRepository.remove(consumerId);

    // 2. Remove consumer from local memory.
    this.consumers = { ...others };
>>>>>>> f6dd8cd (Update ServerStateActions to use Redis instead of local memory)
  }
}
export default class ServerState {
  private static serverState: ServerStateActions;constructor() {
    autoBind(this);
  }
  static getInstance() {
    this.serverState = this.serverState ?? new ServerStateActions();
    return this.serverState;
  }
}
